             +--------------------------+
             |          CS 140          |
             | PROJECT 2: USER PROGRAMS |
             |     DESIGN DOCUMENT      |
             +--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Jaemin Kim <jm611@unist.ac.kr>
Munseong Son <osoli6949@unist.ac.kr>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

               ARGUMENT PASSING
               ================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

-> No additional declaration of type or global / static variable.

---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?

-> Slicing the input string into separate arguments is done using
   strtok_r(). After slicing & counting argument number, we plug 
   the result and thread's stack pointer into push_argv function.

   push_argv function put the argument strings on the stack before
   execution, by using for loop and strlcpy(). This is done by moving
   stack pointer *esp down and copying strings of argv[] into *esp.

   After word-aligning the pointer by subtracting (*esp) % 4,
   we push each arguments into stack from null pointer sentinel
   of argv[argc] to argv[0].

   Then we push the address of argv, and argc. Finally we push fake
   "return address" to ensure the stack frame's structural consistency.

-> Stack overflow is avoided by copying address value to the 
   variable sp_int, subtracting predicted amount of pointer
   "movement" and calling is_user_vaddr((void*)sp_int).
   This checks if stack pointer goes beyond the stack page
   after performing pushes.


---- RATIONALE ----

>> A3: Why does Pintos implement strtok_r() but not strtok()?

-> strtok() uses global data, so it is unsafe in threaded programs
   such as kernels. So, Pintos implement strtok_r(), which takes
   additional argument instead using global variable.

>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.

-> By performing separation in shell instead of kernel, UNIX provides
   protection between kernel and spliting argument, leading to better security.

   Also, by having less function in the kernel, UNIX simplifies kernel
   and maximizes extensibillity by removing potential conflict between
   kernel's separation implementation and other functions from user & kernel.

                 SYSTEM CALLS
                 ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

-> 1. struct file* fd_table[FD_TABLE_SIZE]:
    Thread member array. Stores file pointer in the index fd.
    (fd = file descriptors)

   2. #define FD_TABLE_SIZE 130
    Maximum number + 2 of opened file per process. 2 is reserved for
    stdin (fd 0) and stdout (fd 1), although open() never return these
    two values.

   3. In thread.h (for proces):
   struct thread* parent; -> indicates who the parent is
   struct list children; -> constructs a list of child processes
   struct list_elem childelem; -> becomes the list element for child processes list of parent

   struct semaphore child_sema; -> semaphore for waiting termination of child
   struct semaphore exit_sema; -> semaphore for right order of exiting
                                  (to make sure that exit status is saved)
   struct semaphore load_sema; -> semaphore for completion of loading before returning exec

   bool load_status; -> to pass whether loading was successfully or not */
   int exit_status; -> return-value of calling exit
   struct file* executable; -> current running file (to deny writing while running it)

>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?

-> File descriptors are unique just within a single process. Each file
   descriptor is an index for per-process "fd_table", which stores 
   pointers to corresponding opened file.

---- ALGORITHMS ----

>> B3: Describe your code for reading and writing user data from the
>> kernel.

-> Both reading and writing start with checking the validity of the given
   arguments. Then acquire the lock named "filesys_lock" to prevent race condition.
   This lock is released before returning.

-> 1. int read(int fd, void* buffer, unsigned size)
      After acquiring the lock named "filesys_lock" to ensure there is no
      race condition, read() checks fd(file descriptor).

      If 0, then write user input to the buffer using input_getc().
      Otherwise, check current thread's fd_table to find file corresponding
      to the given fd.

      If such file does not exist, return -1. Otherwise read that file using
      file_read(f, buffer, size).


-> 2. int write(int fd, void* buffer, unsigned size)
      First, check validity of fd. If fd < 1 or fd >= FILE_TABLE_SIZE, return -1.

      If fd == 1, then write to the console using putbuf(buffer, size).
      Otherwise, check if that file exists by searching current thread's fd_table.
      If file does not exist, return -1. Otherwise write buffer to the file using
      file_write function & return it's value.

>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?

-> In the most optimal implementation, copying full page of data should cause
   at most 2 inspections in case of the data is not page-alligned, that is,
   does not start on a virtual address divisible by the page size. If data is
   page-alligned, then just 1 inspection is required. Also, in this implementation,
   at most 2 inspection is required to copy 2 bytes of data in case of the second
   data is page-alligned, otherwise 1.

   In our implementation, write simply stops writing if it reaches the end of the
   kernel page. Furthermore, four pagedir_get_page() calls are made per every 
   write() system call to check validity of the arguments. 
   Assuming that data is split to make at most two segments of page-alligned data,
   at most 8 inspections & at least 4 inspections are made to write 4,096 bytes
   (or 2 bytes) to the kernel. 
   
   This can be improved by checking only that the user pointer points below the
   PHYS_BASE, instead of calling pagedir_get_page() for every validity check.
   For this, proper way to handle page fault needs to be implemented.

>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.

-> It calls process_wait(tid_t child_tid) from the process.c, which does:

   1. Iterate the current thread's child process list until child process
      whose thread's tid is child_tid. If such process does not exist, return -1.

   2. Wait until the child process terminates by waiting semaphore "child_sema".
      After that, record that child's exit status and sema_up another semaphore
      "exit_sema" to continue the child's exitting. Finally, return the recorded
      exit status.

>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated.  System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.

-> check_valid(void* addr) function is implemented to ensure that passed addresses
   are indeed valid. It checks whether: address is not null, address is below 
   PHYS_BASE, address is mapped in the current thread's page directory.

   Each argument is passed into this function to ensure the validity of the pointers.
   In addition, pagedir_get_page() is called once more after check_valid() in some
   cases where the argument is pointer to the pointer.

   Lock that is used to prevent from trying two concurrent writes one same file is
   released when the bad conditon is detected, but before return the value -1.
   Rest of the resources are freed via exit(-1) call, which calls thread_exit(), which ensures
   that every resource that thread acquired is freed.

   In some edge cases (ex. *(int *)NULL in bad-read.c), exception.c assigns -1 to that 
   frame's EAX register, and print message just like exit(-1). It also calls kill(),
   which calls thread_exit() to ensure that resources are freed.

---- SYNCHRONIZATION ----

>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?  How is the load
>> success/failure status passed back to the thread that calls "exec"?

-> We implement load_status, which becomes false if load() fails.
   "exec" waits its child process's loading by searching its children list to find
   the process corresponds with the result pid, then waiting its "load_sema", which is
   released after load().

   If that child's load_status is false, return -1. Otherwise return child's pid. 

>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?

-> Resources are freed in thread_exit(), so no additional resource management
   is required. Semaphore "child_sema" is used to wait for its child to exit,
   and semaphore "exit_sema" prevents child process from freeing all its resources
   including its exit status before parent process acquire its return value.

---- RATIONALE ----

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?

-> Accessing user memory by checking validity & dereferencing stack pointer is
   simple & easy to understand and implement. This makes the overall debugging and
   future improvement much easier.

>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?

-> Advantages: We can read any file descriptor in O(1) time.

   Disadvantages: File descriptor's number cannot exceed 130, limiting the upper
                  limit of open files.
                  Finding empty file descriptor takes O(n) time.

>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?

-> No changes are made. However, if we can map tid_t with pid_t without
   using identity mapping, we can implement multi-thread process system.

                 CONTRIBUTION
                 ============

Jaemin Kim (40%): Overall project planning & management. implementation
of process_wait and push_argv, halt() and wait(). Provided skeleton code
of syscall handler function. In project 2-2, Worked mostly with synchronization
problem and resource management.

Munseong Son (60%): Implemented sanity check of syscall_init function
and stack overflow check in push_argv. Implemented create, open, close function.
In project 2-2, Added the initial version of most syscall functions and suggested
a list of things to do.

-> 40:60 contribution.
